## Перечислите все специальные функции-члены класса, включая перемещающие операции.

```cpp
class ClassName
{
    ClassName() {};                                 // конструктор по умолчанию
    ~ClassName() {};                                // деструктор
    ClassName(const ClassName& other) {};           // конструктор копирования
    ClassName(ClassName&& other) {}                 // конструктор перемещения
    ClassName& operator=(const ClassName& other) {} // оператор присваивания копированием
    ClassName& operator=(ClassName&& other) {}      // оператор присваивания перемещением
};
```

## Приведите примеры операторов, которые можно, нельзя и не рекомендуется перегружать.

* Можно перегружать: `[]`, `()`, `+`, `>`, `<<`

* Не рекомендуется перегружать:  
`&` (может потребоваться доступ к адресу переменной, при перегрузке его будет невозможно получить)  
`,` (могут возникнуть проблемы с читаемостью кода)

* Нельзя перегружать: `::`, `.`, `.*`

## О каких преобразованиях следует помнить при проектировании операторов?

О неявных преобразованиях типа. При перегрузке операторов компилятор может автоматически привести тип передаваемого аргумента к типу принимаемого аргумента. Это может привести к некорректной работе оператора. Чтобы запретить неявное преобразование, используется ключевое слово `explicit`

## Опишите классификацию выражений на основе перемещаемости и идентифицируемости.

|                              | Перемещаемо (rvalue)| Не перемещаемо |
| ---------------------------- | :------------------:| :------------: | 
| **Идентифицируемо (gvalue)** | xvalue              | lvalue         |
| **Не идентифицируемо**       | prvalue             |                |

## Зачем нужны `rvalue`-ссылки?

Для реализации семантики перемещения.

## Почему семантика перемещения лучше копирования?

Семантика перемещения позволяет оптимизировать расход памяти при инициализации и конструировании новых объектов (происходит перемещение данных вместо копирования).

## Что делает функция `std::move` и когда нет необходимости явно её вызывать?

Функция `std::move` изменяет тип объекта на `rvalue`-ссылку, что позволяет применить семантику перемещений. Нет необходимости вызывать при возврате объекта функцией, поскольку в таком случае компилятор автоматически использует семантику перемещений.

## Кем выполняется непосредственная работа по перемещению?

Конструктором перемещения и оператором присваивания перемещением.

## Когда может потребоваться пользовательская реализация специальных функций-членов класса?

Когда функции по умолчанию обрабатывают данные не так, как предполагается. 

## Для чего нужны ключевые слова `default` и `delete` в объявлении специальных функций-членов класса?

Ключевое слово `default` позволяет явно указать, что используется специальная функция-член по умолчанию (генерируется компилятором).

```cpp
class ClassName
{
    ClassName() = default;
};
```

Ключевое слово `default` позволяет запретить создание специальной функции-члена по умолчанию.

```cpp
class ClassName
{
    ClassName() = delete;
};
```